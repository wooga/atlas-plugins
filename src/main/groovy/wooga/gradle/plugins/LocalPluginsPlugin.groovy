package wooga.gradle.plugins

import org.apache.maven.artifact.versioning.DefaultArtifactVersion
import org.gradle.api.JavaVersion
import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.Task
import org.gradle.api.artifacts.Configuration
import org.gradle.api.artifacts.ResolutionStrategy
import org.gradle.api.artifacts.dsl.DependencyHandler
import org.gradle.api.file.DuplicatesStrategy
import org.gradle.api.file.SourceDirectorySet
import org.gradle.api.plugins.GroovyPlugin
import org.gradle.api.plugins.JavaPlugin
import org.gradle.api.plugins.JavaPluginExtension
import org.gradle.api.provider.Provider
import org.gradle.api.publish.maven.MavenPublication
import org.gradle.api.publish.maven.plugins.MavenPublishPlugin
import org.gradle.api.publish.plugins.PublishingPlugin
import org.gradle.api.reporting.ReportingExtension
import org.gradle.api.tasks.Copy
import org.gradle.api.tasks.SourceSet
import org.gradle.api.tasks.Sync
import org.gradle.api.tasks.TaskContainer
import org.gradle.api.tasks.TaskProvider
import org.gradle.api.tasks.javadoc.Groovydoc
import org.gradle.api.tasks.testing.Test
import org.gradle.language.base.plugins.LifecycleBasePlugin
import org.gradle.plugin.devel.GradlePluginDevelopmentExtension
import org.gradle.plugin.devel.plugins.JavaGradlePluginPlugin
import org.gradle.plugins.ide.idea.IdeaPlugin
import org.gradle.plugins.ide.idea.model.IdeaModel
import org.gradle.testing.jacoco.plugins.JacocoPlugin
import org.gradle.testing.jacoco.tasks.JacocoReport
import org.gradle.testing.jacoco.tasks.JacocoReportsContainer
import org.sonarqube.gradle.SonarQubeExtension
import wooga.gradle.plugins.internal.AutogeneratedGroovyFile
import wooga.gradle.plugins.sonarqube.SonarQubeConfiguration

import java.util.concurrent.Callable

class LocalPluginsPlugin implements Plugin<Project> {

    static final String INTEGRATION_TEST_TASK_NAME = "integrationTest"
    private static final String INTEGRATION_TEST_SOURCE = "src/integrationTest/groovy"
    static final String DOC_EXPORT_DIR = "docs/api"
    static final String PUBLISH_GROOVY_DOCS_TASK_NAME = "publishGroovydocs"
    @Override
    void apply(Project project) {
        project.pluginManager.with {
            apply(GroovyPlugin)
            apply(IdeaPlugin)
            apply(JacocoPlugin)
            apply(MavenPublishPlugin)
            apply(JavaGradlePluginPlugin)
            apply(SonarQubeConfiguration.PLUGIN_CLASS)
        }



        def integrationTestTask = setupIntegrationTestTask(project, project.tasks)
        def testTask = project.tasks.named(JavaPlugin.TEST_TASK_NAME, Test)
        project.tasks.withType(Test).configureEach { Test test -> test.useJUnitPlatform() }

        configureSourceCompatibility(project, JavaVersion.VERSION_1_8)
        configureGroovyDocsTask(project)
        configureJacocoTestReport(project, integrationTestTask, testTask)
        configureSonarQubeExtension(project, SonarQubeConfiguration.withEnvVarPropertyFallback(project))
        configureTestReportOutput(project)

        setupRepositories(project)
        setupDependencies(project)
        forceGroovyVersion(project, "3.0.13")
        generateSpockConfigFile(project, """unroll {defaultPattern '#featureName[#iterationIndex]'}""")
        project.publishing {
            publications {
                mavenJava(MavenPublication) {
                    from project.components.java
                }
            }
        }
    }

    private static void setupRepositories(Project project) {
        def repositories = project.repositories
        repositories.add(repositories.mavenCentral())
        repositories.add(repositories.gradlePluginPortal())
    }

    private static void setupDependencies(Project project) {
        def javaExt = project.extensions.getByType(JavaPluginExtension)
        DependencyHandler dependencies = project.getDependencies();
        dependencies.add("api", dependencies.gradleApi())
        dependencies.add("implementation", 'commons-io:commons-io:[2.7,3)')
        dependencies.add("testImplementation", 'com.github.stefanbirkner:system-rules:[1,2)')
        dependencies.add("testImplementation", 'org.spockframework:spock-core:2.3-groovy-3.0', {
            exclude group: "org.codehaus.groovy"
        })
        dependencies.add("testImplementation", 'org.spockframework:spock-junit4:2.3-groovy-3.0', {
            exclude group: "org.codehaus.groovy"
        })
//      nebula-test is compatible with groovy 3/spock 2/gradle 7 from 10.0+
        dependencies.add("testImplementation", 'com.netflix.nebula:nebula-test:[10,11)')
        dependencies.add("integrationTestImplementation", javaExt.sourceSets.getByName("test").output)
    }

    private static void configureGroovyDocsTask(final Project project) {
        TaskContainer tasks = project.tasks
        def groovyDocTask = tasks.named(GroovyPlugin.GROOVYDOC_TASK_NAME, Groovydoc)

        tasks.withType(Groovydoc).configureEach { Groovydoc task ->
            if (task.name == GroovyPlugin.GROOVYDOC_TASK_NAME) {
                GradlePluginDevelopmentExtension extension = project.getExtensions().getByType(GradlePluginDevelopmentExtension)
                Callable<String> docTitle = {
                    if (extension.plugins[0]) {
                        return "${extension.plugins.first().displayName} API".toString()
                    }
                    return null
                }
                def conventionMapping = task.getConventionMapping()
                conventionMapping.use = { true }
                conventionMapping.footer = docTitle
                conventionMapping.windowTitle = docTitle
                conventionMapping.docTitle = docTitle
                conventionMapping.noVersionStamp = { true }
                conventionMapping.noTimestamp = { true }
            }
        }

        def publishGroovydocTask = tasks.register(PUBLISH_GROOVY_DOCS_TASK_NAME, Sync) {
            it.description = "Publish groovy docs to output directory ${DOC_EXPORT_DIR}"
            it.group = PublishingPlugin.PUBLISH_TASK_GROUP
            it.from(groovyDocTask.map{it.outputs.files })
            it.destinationDir = project.file(DOC_EXPORT_DIR)
        }

        tasks.named(PublishingPlugin.PUBLISH_LIFECYCLE_TASK_NAME) {
            it.dependsOn(publishGroovydocTask)
        }
    }

    private static configureSonarQubeExtension(final Project project, SonarQubeConfiguration sonarConfig) {
        SonarQubeExtension sonarExt = project.rootProject.extensions.getByType(SonarQubeExtension)

        def javaConvention = project.extensions.findByType(JavaPluginExtension)

        sonarExt.properties(sonarConfig.generateSonarProperties(
                project.provider{ project.name },
                project.provider{ null as String }, javaConvention))

        Task sonarTask = project.rootProject.tasks.getByName(SonarQubeConfiguration.TASK_NAME)
        sonarTask.onlyIf { System.getenv('CI') }
    }

    private static configureJacocoTestReport(final Project project,
                                             TaskProvider<? extends Task> integrationTestTask,
                                             TaskProvider<? extends Task> testTask) {
        project.tasks.withType(JacocoReport).configureEach { JacocoReport jacocoReport ->
            if (jacocoReport.name == "jacoco" + JavaPlugin.TEST_TASK_NAME.capitalize() + "Report") {
                jacocoReport.reports{ JacocoReportsContainer configurableReports ->
                    configurableReports.xml.enabled = true
                    configurableReports.html.enabled = true
                }
                jacocoReport.executionData(integrationTestTask.get(), testTask.get())
            }
        }
    }

    private static void configureTestReportOutput(final Project project) {
        def reporting = project.extensions.getByName(ReportingExtension.NAME) as ReportingExtension
        project.tasks.withType(Test).configureEach { task ->
            task.reports.html.setDestination(project.file("${reporting.baseDir}/${task.name}"))
        }
    }

    private static TaskProvider<Test> setupIntegrationTestTask(final Project project, final TaskContainer tasks) {
        def javaConvention = project.extensions.findByType(JavaPluginExtension)

        def integrationTestSourceSet = setupIntegrationTestSourceSet(project, javaConvention)
        setupIntegrationTestConfiguration(project, javaConvention)
        setupIntegrationTestIdeaModule(project, integrationTestSourceSet.get())

        def integrationTestTask = tasks.register(INTEGRATION_TEST_TASK_NAME, Test)
        def testTask = tasks.named(JavaPlugin.TEST_TASK_NAME)
        integrationTestTask.configure {
            it.with {
                setTestClassesDirs(integrationTestSourceSet.get().output.classesDirs)
                classpath = integrationTestSourceSet.get().runtimeClasspath
                outputs.upToDateWhen { false }
            }
            it.mustRunAfter testTask
        }
        tasks.named(LifecycleBasePlugin.CHECK_TASK_NAME).configure {
            it.dependsOn integrationTestTask
        }


        return integrationTestTask
    }

    private static setupIntegrationTestIdeaModule(final Project project, SourceSet integrationSourceSet) {
        def ideaModel = project.extensions.getByType(IdeaModel.class)
        ideaModel.module.testSourceDirs += project.file(INTEGRATION_TEST_SOURCE)
        ideaModel.module.scopes["TEST"]["plus"] += [project.configurations.getByName(integrationSourceSet.compileClasspathConfigurationName)]
    }

    private static void setupIntegrationTestConfiguration(Project project, final JavaPluginExtension javaExt) {
        def test = javaExt.sourceSets.getByName("test")
        def integrationTest = javaExt.sourceSets.getByName("integrationTest")

        def configurations = project.configurations
        def testImplementation = configurations.getByName(test.implementationConfigurationName)
        def testRuntimeOnly = configurations.getByName(test.runtimeOnlyConfigurationName)

        def integrationTestImplementation = configurations.getByName(integrationTest.implementationConfigurationName)
        integrationTestImplementation.extendsFrom(testImplementation)

        def integrationTestRuntimeOnly = configurations.getByName(integrationTest.runtimeOnlyConfigurationName)
        integrationTestRuntimeOnly.extendsFrom(testRuntimeOnly)
    }

    private static void addSrcDirIfNotExists(SourceDirectorySet dirSet, File toAdd) {
        if(!dirSet.srcDirs.contains(toAdd)) {
            dirSet.srcDir(toAdd)
        }
    }

    private static Provider<SourceSet> setupIntegrationTestSourceSet(final Project project, final JavaPluginExtension javaExt) {
        def main = javaExt.sourceSets.named("main")
        def test = javaExt.sourceSets.named("test")
        def sourceSet = javaExt.sourceSets.register("integrationTest") {sourceSet ->
            sourceSet.compileClasspath = project.files(main.get().compileClasspath, test.get().compileClasspath, sourceSet.compileClasspath)
            sourceSet.runtimeClasspath = project.files(main.get().compileClasspath, test.get().compileClasspath, sourceSet.runtimeClasspath)
            //duplicate avoidance needed due to gradle bug: https://github.com/gradle/gradle/issues/17236
            addSrcDirIfNotExists(sourceSet.groovy as SourceDirectorySet,
                    new File(project.projectDir, "src/" + sourceSet.getName() + "/groovy"))
            addSrcDirIfNotExists(sourceSet.resources,
                    new File(project.projectDir, "src/" + sourceSet.getName() + "/resources"))
        }
        return sourceSet
    }



    static void configureSourceCompatibility(Project project, JavaVersion javaVersion) {
        JavaPluginExtension javaExtension = project.extensions.getByType(JavaPluginExtension)
        javaExtension.sourceCompatibility = javaVersion
    }

    private static void forceGroovyVersion(Project project, String minimumVersion) {
        project.configurations.all({ Configuration configuration ->
            configuration.resolutionStrategy({ ResolutionStrategy strategy ->
                def localGroovyVersion = new DefaultArtifactVersion(GroovySystem.getVersion())
                def localGroovy = localGroovyVersion >= new DefaultArtifactVersion(minimumVersion) ? GroovySystem.getVersion() : minimumVersion
                strategy.force("org.codehaus.groovy:groovy:${localGroovy}")
                strategy.force("org.codehaus.groovy:groovy-all:${localGroovy}")
                strategy.force("org.codehaus.groovy:groovy-macro:${localGroovy}")
                strategy.force("org.codehaus.groovy:groovy-nio:${localGroovy}")
                strategy.force("org.codehaus.groovy:groovy-sql:${localGroovy}")
                strategy.force("org.codehaus.groovy:groovy-xml:${localGroovy}")
            })
        })
    }

    private static AutogeneratedGroovyFile generateSpockConfigFile(Project project, String contents) {
        def testResDir = project.extensions.getByType(JavaPluginExtension).sourceSets.named("test").map {
            it.allSource.sourceDirectories.first().absolutePath
        }
        def targetDir = project.layout.projectDirectory.dir(testResDir).get()
        def spockConfig =  AutogeneratedGroovyFile.getOrCreate(targetDir.file("SpockConfig.groovy").asFile)
        spockConfig.overwriteAutogenerated(contents)
        return spockConfig
    }
}
